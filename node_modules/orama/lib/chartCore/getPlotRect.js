"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/builtin/interopRequireDefault");

exports.__esModule = true;
exports.getTextWidth = getTextWidth;
exports.getMaxTextWidth = getMaxTextWidth;
exports.getPlotRect = getPlotRect;

var _sum2 = _interopRequireDefault(require("lodash/sum"));

var _reduce2 = _interopRequireDefault(require("lodash/reduce"));

var _includes2 = _interopRequireDefault(require("lodash/includes"));

var _canvasUtils = require("../utils/canvasUtils");

var _rectUtils = require("../utils/rectUtils");

var _getForKey = require("./getForKey");

var _defaults = require("./defaults");

/*
`addPlotRect` calculate and assign the plotRect to a new props.
props.size gets insetted by props.margin to generate the plotRect.
when props.margin is not defined (or only partially defined), addPlotRect smartly calculates the margins, by taking into consideration axis label, ticks width and backgroundOffset.

@calling logic
addPlotRect{
  getTopMargin{}
  getBottomMargin{}
  getLeftMargin{
    getMaxTextWidth{}
  }
  getRightMargin{
    getTextWidth{}
  }
}

@example
addPlotRect({size})
returns {size, plotRect}
*/
function getTextWidth(theme, string) {
  var ctx = (0, _canvasUtils.getCachedContext)();
  ctx.save();
  ctx.font = theme.axisTickFontSize + "px " + theme.fontFamilyMono;

  var _ctx$measureText = ctx.measureText(string),
      width = _ctx$measureText.width;

  ctx.restore();
  return width;
}
/*
get the maximum width of the strings contained in `ticks`.
Uses a offscreen canvas for doing the measure and takes into consideration the theme object.
*/


function getMaxTextWidth(theme, ticks) {
  var ctx = (0, _canvasUtils.getCachedContext)();
  ctx.save();
  ctx.font = theme.axisTickFontSize + "px " + theme.fontFamilyMono;
  var maxWidth = (0, _reduce2.default)(ticks, function (acc, d) {
    return Math.max(acc, ctx.measureText(d.text).width);
  }, 0);
  ctx.restore();
  return maxWidth;
}

function getTopMargin(props) {
  var _props$backgroundOffs = props.backgroundOffset,
      backgroundOffset = _props$backgroundOffs === void 0 ? _defaults.BACKGROUND_OFFSET : _props$backgroundOffs,
      _props$margin = props.margin,
      margin = _props$margin === void 0 ? {} : _props$margin,
      theme = props.theme,
      y = props.y,
      _props$yShowTicks = props.yShowTicks,
      yShowTicks = _props$yShowTicks === void 0 ? _defaults.SHOW_TICKS : _props$yShowTicks;
  if (margin.top !== undefined) return margin.top + backgroundOffset;
  if (yShowTicks === false || !y) return backgroundOffset;
  return Math.max(backgroundOffset, theme.axisTickFontSize / 2);
}

function getBottomMargin(props) {
  var theme = props.theme;
  var _props$backgroundOffs2 = props.backgroundOffset,
      backgroundOffset = _props$backgroundOffs2 === void 0 ? _defaults.BACKGROUND_OFFSET : _props$backgroundOffs2,
      groupedKeys = props.groupedKeys,
      _props$margin2 = props.margin,
      margin = _props$margin2 === void 0 ? {} : _props$margin2,
      _props$xShowTicks = props.xShowTicks,
      xShowTicks = _props$xShowTicks === void 0 ? _defaults.SHOW_TICKS : _props$xShowTicks,
      _props$xShowLabel = props.xShowLabel,
      xShowLabel = _props$xShowLabel === void 0 ? _defaults.SHOW_LABELS : _props$xShowLabel,
      _props$xTickOffset = props.xTickOffset,
      xTickOffset = _props$xTickOffset === void 0 ? (0, _defaults.AXIS_TICK_OFFSET)(theme) : _props$xTickOffset,
      _props$xLabelOffset = props.xLabelOffset,
      xLabelOffset = _props$xLabelOffset === void 0 ? (0, _defaults.AXIS_LABEL_OFFSET)(theme) : _props$xLabelOffset;
  if (margin.bottom !== undefined) return margin.bottom + backgroundOffset;
  if (!(0, _includes2.default)(groupedKeys, 'x')) return backgroundOffset;
  return (0, _sum2.default)([backgroundOffset, xShowTicks ? xTickOffset + theme.axisTickFontSize : 0, xShowLabel ? xLabelOffset + theme.axisLabelFontSize : 0]);
}

function getLeftMargin(props) {
  var theme = props.theme;
  var _props$backgroundOffs3 = props.backgroundOffset,
      backgroundOffset = _props$backgroundOffs3 === void 0 ? _defaults.BACKGROUND_OFFSET : _props$backgroundOffs3,
      groupedKeys = props.groupedKeys,
      _props$margin3 = props.margin,
      margin = _props$margin3 === void 0 ? {} : _props$margin3,
      _props$yShowTicks2 = props.yShowTicks,
      yShowTicks = _props$yShowTicks2 === void 0 ? _defaults.SHOW_TICKS : _props$yShowTicks2,
      _props$yShowLabel = props.yShowLabel,
      yShowLabel = _props$yShowLabel === void 0 ? _defaults.SHOW_LABELS : _props$yShowLabel,
      _props$yTickOffset = props.yTickOffset,
      yTickOffset = _props$yTickOffset === void 0 ? (0, _defaults.AXIS_TICK_OFFSET)(theme) : _props$yTickOffset,
      _props$yLabelOffset = props.yLabelOffset,
      yLabelOffset = _props$yLabelOffset === void 0 ? (0, _defaults.AXIS_LABEL_OFFSET)(theme) : _props$yLabelOffset;
  if (margin.left !== undefined) return margin.left + backgroundOffset;
  if (!(0, _includes2.default)(groupedKeys, 'y')) return backgroundOffset;

  if (!yShowTicks) {
    return (0, _sum2.default)([backgroundOffset, yShowLabel ? yLabelOffset + theme.axisLabelFontSize : 0]);
  }

  var yRange = props.yRange || (0, _getForKey.getRange)(props, 'y');
  var yTickCount = props.yTickCount || (0, _getForKey.getTickCount)(Object.assign({}, props, {
    yRange: yRange
  }), 'y');
  var yTicks = props.yTicks || (0, _getForKey.getTicks)(Object.assign({}, props, {
    yTickCount: yTickCount
  }), 'y');
  var yMaxTickWidth = getMaxTextWidth(theme, yTicks);
  return (0, _sum2.default)([backgroundOffset, yMaxTickWidth, yShowTicks ? yTickOffset : 0, yShowLabel ? yLabelOffset + 5 + theme.axisLabelFontSize : 0]);
}

function getRightMargin(props) {
  var _props$backgroundOffs4 = props.backgroundOffset,
      backgroundOffset = _props$backgroundOffs4 === void 0 ? _defaults.BACKGROUND_OFFSET : _props$backgroundOffs4,
      _props$margin4 = props.margin,
      margin = _props$margin4 === void 0 ? {} : _props$margin4,
      x = props.x,
      _props$xShowTicks2 = props.xShowTicks,
      xShowTicks = _props$xShowTicks2 === void 0 ? _defaults.SHOW_TICKS : _props$xShowTicks2;
  if (margin.right !== undefined) return margin.right + backgroundOffset;
  if (!x || !xShowTicks) return backgroundOffset;
  return backgroundOffset;
}

function getPlotRect(props) {
  if (props.plotRect) return props;
  var _props$backgroundOffs5 = props.backgroundOffset,
      backgroundOffset = _props$backgroundOffs5 === void 0 ? _defaults.BACKGROUND_OFFSET : _props$backgroundOffs5,
      groupedKeys = props.groupedKeys,
      width = props.width,
      _props$height = props.height,
      height = _props$height === void 0 ? props.width * props.proportion : _props$height;
  var top = getTopMargin(props);
  var bottom = getBottomMargin(props);
  var partialPlotRect = (0, _rectUtils.marginInset)({
    bottom: bottom,
    top: top
  }, {
    width: width,
    height: height
  });
  var left = getLeftMargin(Object.assign({}, props, {
    plotRect: partialPlotRect
  }));
  partialPlotRect = (0, _rectUtils.marginInset)({
    bottom: bottom,
    top: top,
    left: left
  }, {
    width: width,
    height: height
  });
  var right = getRightMargin(Object.assign({}, props, {
    plotRect: partialPlotRect
  }));
  var margin = {
    left: left,
    bottom: bottom,
    top: top,
    right: right
  };
  var newWidth = width;
  var newHeight = height;
  var plotRect = (0, _rectUtils.marginInset)(margin, {
    width: width,
    height: height
  });

  if (!(0, _includes2.default)(groupedKeys, 'x')) {
    newWidth -= plotRect.width;
    plotRect.width = 0;
  }

  if (!(0, _includes2.default)(groupedKeys, 'y')) {
    newHeight -= plotRect.height;
    plotRect.height = 0;
  }

  if (plotRect.height < 0) {
    plotRect.height = 0;
    newHeight = top + bottom;
  }

  if (plotRect.width < 0) {
    plotRect.width = 0;
    newWidth = left + right;
  }

  return {
    backgroundOffset: backgroundOffset,
    margin: margin,
    plotRect: plotRect,
    width: newWidth,
    height: newHeight
  };
}