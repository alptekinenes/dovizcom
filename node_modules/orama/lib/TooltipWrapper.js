"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/builtin/interopRequireDefault");

var _interopRequireWildcard = require("@babel/runtime/helpers/builtin/interopRequireWildcard");

exports.__esModule = true;
exports.getTooltipPosition = getTooltipPosition;
exports.default = void 0;

var React = _interopRequireWildcard(require("react"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _stateHOC = _interopRequireDefault(require("./utils/stateHOC"));

var _windowUtils = require("./utils/windowUtils");

var _BlockSize = _interopRequireDefault(require("./utilComponents/BlockSize"));

var _Portal = _interopRequireDefault(require("./utilComponents/Portal"));

var _Tooltip = _interopRequireDefault(require("./Tooltip"));

// Copyright 2018 Kensho Technologies, LLC.
var TOOLTIP_MARGIN = 15;

function handleBlockSizeUpdate(props, childProps) {
  props.onState({
    width: childProps.width,
    height: childProps.height
  });
}

function getTooltipPosition(props) {
  var mouse = props.mouse,
      width = props.width,
      height = props.height;

  if (!width || !height) {
    return {};
  }

  var _window = (0, _windowUtils.getWindow)();

  var pos = {};

  if (mouse.x + width + TOOLTIP_MARGIN * 2 + 1 > _window.innerWidth) {
    if (width + TOOLTIP_MARGIN * 2 > mouse.x) {
      pos.left = 0;
    } else {
      pos.right = _window.innerWidth - mouse.x;
    }
  } else {
    pos.left = mouse.x;
  }

  if (mouse.y + height + TOOLTIP_MARGIN * 2 + 1 > _window.innerHeight) {
    if (height + TOOLTIP_MARGIN * 2 > mouse.y) {
      pos.top = 0;
    } else {
      pos.bottom = _window.innerHeight - mouse.y;
    }
  } else {
    pos.top = mouse.y;
  }

  return pos;
}

function TooltipWrapper(props) {
  if (!props.mouse || !props.hoverData) return null;
  var _props$layerProps$Too = props.layerProps.Tooltip,
      Tooltip = _props$layerProps$Too === void 0 ? _Tooltip.default : _props$layerProps$Too;
  return React.createElement(_Portal.default, null, React.createElement(_BlockSize.default, {
    onUpdate: function onUpdate(childProps) {
      return handleBlockSizeUpdate(props, childProps);
    },
    style: Object.assign({
      margin: TOOLTIP_MARGIN,
      pointerEvents: 'none',
      position: 'fixed',
      zIndex: '999999'
    }, getTooltipPosition(props))
  }, React.createElement(Tooltip, {
    hoverData: props.hoverData,
    layerProps: props.layerProps,
    theme: props.theme
  })));
}

TooltipWrapper.propTypes = process.env.NODE_ENV !== "production" ? {
  hoverData: _propTypes.default.oneOfType([_propTypes.default.array, _propTypes.default.object]),
  layerProps: _propTypes.default.object,
  mouse: _propTypes.default.object,
  theme: _propTypes.default.object
} : {};

var _default = (0, _stateHOC.default)(TooltipWrapper);

exports.default = _default;