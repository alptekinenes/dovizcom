"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/builtin/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/builtin/interopRequireDefault");

exports.__esModule = true;
exports.default = void 0;

var _includes2 = _interopRequireDefault(require("lodash/includes"));

var React = _interopRequireWildcard(require("react"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _stateHOC = _interopRequireDefault(require("../utils/stateHOC"));

var _Layer = require("../Layer");

// Copyright 2018 Kensho Technologies, LLC.
var BRUSH_ELEMENT_NAMES = ['brushesCenter', 'brushesLeft', 'brushesRight', 'brushesTop', 'brushesBottom', 'brushesLeftTop', 'brushesRightTop', 'brushesRightBottom', 'brushesLeftBottom'];

var reorder = function reorder(bounds) {
  return {
    x1: Math.min(bounds.x1, bounds.x2),
    x2: Math.max(bounds.x1, bounds.x2),
    y1: Math.min(bounds.y1, bounds.y2),
    y2: Math.max(bounds.y1, bounds.y2)
  };
};

function isOutOfBounds(bounds, plotRect) {
  if (bounds.x1 < plotRect.x || bounds.x2 > plotRect.x + plotRect.width || bounds.y1 < plotRect.y || bounds.y2 > plotRect.y + plotRect.height) return true;
  return false;
}

function constraintToPlotRect(bounds, childProps) {
  var plotRect = childProps.rootProps.plotRect;
  var x1 = bounds.x1,
      x2 = bounds.x2,
      y1 = bounds.y1,
      y2 = bounds.y2;
  if (x1 < plotRect.x) x1 = plotRect.x;
  if (x2 > plotRect.x + plotRect.width) x2 = plotRect.x + plotRect.width;
  if (y1 < plotRect.y) y1 = plotRect.y;
  if (y2 > plotRect.y + plotRect.height) y2 = plotRect.y + plotRect.height;
  return {
    x1: x1,
    x2: x2,
    y1: y1,
    y2: y2
  };
}

function domainToBounds(props, childProps) {
  var rootProps = childProps.rootProps;
  return {
    x1: rootProps.xScale(props.xDomain[0]),
    x2: rootProps.xScale(props.xDomain[1]),
    y1: rootProps.yScale(props.yDomain[0]),
    y2: rootProps.yScale(props.yDomain[1])
  };
}

function boundsToDomain(bounds, childProps) {
  var rootProps = childProps.rootProps;
  return {
    xDomain: [rootProps.xScale.invert(bounds.x1), rootProps.xScale.invert(bounds.x2)],
    yDomain: [rootProps.yScale.invert(bounds.y1), rootProps.yScale.invert(bounds.y2)]
  };
}

var getBrushData = function getBrushData(props) {
  return {
    x1: props.xDomain[0],
    x2: props.xDomain[1],
    y1: props.yDomain[0],
    y2: props.yDomain[1]
  };
};

function updateBounds(props, childProps, partialBounds) {
  var newBounds = reorder(Object.assign({}, props._bounds, partialBounds));

  if (isOutOfBounds(newBounds, childProps.rootProps.plotRect)) {
    var constrainedBounds = constraintToPlotRect(newBounds, childProps);
    props.onUpdate(boundsToDomain(constrainedBounds, childProps));
  } else {
    props.onUpdate(boundsToDomain(newBounds, childProps));
  }
}

function mouseDown(props, childProps) {
  var brushElementName = childProps.renderDatum && childProps.renderDatum.name;

  if (!(0, _includes2.default)(BRUSH_ELEMENT_NAMES, brushElementName)) {
    props.onState({
      _bounds: {
        x1: childProps.localMouse.x,
        y1: childProps.localMouse.y
      },
      brushElementName: brushElementName
    });
    props.onUpdate({
      xDomain: undefined,
      yDomain: undefined
    });
  } else {
    props.onState({
      _bounds: domainToBounds(props, childProps),
      brushElementName: brushElementName
    });
  }
}

function mouseDrag(props, childProps) {
  if (props.brushElementName === 'brushesCenter') {
    var bounds = domainToBounds(props, childProps);
    var mBounds = {
      x1: bounds.x1 - childProps.mouseDelta.x,
      x2: bounds.x2 - childProps.mouseDelta.x,
      y1: bounds.y1 - childProps.mouseDelta.y,
      y2: bounds.y2 - childProps.mouseDelta.y
    };

    if (isOutOfBounds(mBounds, childProps.rootProps.plotRect)) {
      var constrainedBounds = constraintToPlotRect(bounds, childProps);
      props.onUpdate(boundsToDomain(constrainedBounds, childProps));
    } else {
      props.onUpdate(boundsToDomain(mBounds, childProps));
    }
  } else if (props.brushElementName === 'brushesLeft') {
    updateBounds(props, childProps, {
      x1: childProps.localMouse.x
    });
  } else if (props.brushElementName === 'brushesRight') {
    updateBounds(props, childProps, {
      x2: childProps.localMouse.x
    });
  } else if (props.brushElementName === 'brushesTop') {
    updateBounds(props, childProps, {
      y1: childProps.localMouse.y
    });
  } else if (props.brushElementName === 'brushesBottom') {
    updateBounds(props, childProps, {
      y2: childProps.localMouse.y
    });
  } else if (props.brushElementName === 'brushesLeftTop') {
    updateBounds(props, childProps, {
      x1: childProps.localMouse.x,
      y1: childProps.localMouse.y
    });
  } else if (props.brushElementName === 'brushesRightTop') {
    updateBounds(props, childProps, {
      x2: childProps.localMouse.x,
      y1: childProps.localMouse.y
    });
  } else if (props.brushElementName === 'brushesRightBottom') {
    updateBounds(props, childProps, {
      x2: childProps.localMouse.x,
      y2: childProps.localMouse.y
    });
  } else if (props.brushElementName === 'brushesLeftBottom') {
    updateBounds(props, childProps, {
      x1: childProps.localMouse.x,
      y2: childProps.localMouse.y
    });
  } else {
    var _bounds = reorder(Object.assign({}, props._bounds, {
      x2: childProps.localMouse.x,
      y2: childProps.localMouse.y
    }));

    var cBounds = constraintToPlotRect(_bounds, childProps);
    props.onUpdate(boundsToDomain(cBounds, childProps));
  }

  if (props.onMouseDown) props.onMouseDown();
}

function mouseUp(props) {
  if (props.onMouseUp) props.onMouseUp();
}

function handleChart(props, childProps) {
  switch (childProps.action) {
    case 'mouseDown':
      mouseDown(props, childProps);
      break;

    case 'mouseDrag':
      mouseDrag(props, childProps);
      break;

    case 'mouseUp':
      mouseUp(props, childProps);
      break;

    default:
  }
}

function StatelessBrush(props) {
  var child = React.Children.only(props.children);

  if (child.type.displayName === 'ChartWidthHOC') {
    var BrushElement = React.createElement(_Layer.Brushes, Object.assign({
      data: [getBrushData(props)],
      fillAlphaValue: props.fillAlphaValue,
      fillValue: props.fillValue,
      key: "brushes",
      lineWidthValue: props.lineWidthValue,
      skipExtractArrays: true,
      strokeValue: props.strokeValue,
      tooltipShowKeys: false,
      x1: "x1",
      x2: "x2",
      y1: "y1",
      y2: "y2"
    }, props));
    var layers = React.Children.toArray(child.props.children).concat(BrushElement);
    return React.cloneElement(child, {
      onUpdate: function onUpdate(childProps) {
        return handleChart(props, childProps);
      }
    }, layers);
  }

  return React.createElement("div", null);
}

StatelessBrush.propTypes = process.env.NODE_ENV !== "production" ? {
  children: _propTypes.default.node,
  fillAlphaValue: _propTypes.default.number,
  fillValue: _propTypes.default.number,
  lineWidthValue: _propTypes.default.number,
  strokeValue: _propTypes.default.string,
  xDomain: _propTypes.default.array,
  yDomain: _propTypes.default.array
} : {};
StatelessBrush.defaultProps = {
  xDomain: [],
  yDomain: []
};

var _default = (0, _stateHOC.default)(StatelessBrush);

exports.default = _default;