import _findLast from "lodash/findLast";
import _compact from "lodash/compact";
import _flatten from "lodash/flatten";
import _filter from "lodash/filter";
import _sum from "lodash/sum";
import _map from "lodash/map";
import _includes from "lodash/includes";
// Copyright 2018 Kensho Technologies, LLC.
import * as React from 'react';
import PropTypes from 'prop-types';
import DEFAULT_THEME from '../defaultTheme';
import { BACKGROUND_OFFSET } from '../chartCore/defaults';
import { getPath2D } from '../utils/path2DUtils';
import { getTicks } from '../chartCore/getForKey';
import { inset } from '../utils/rectUtils';
import CanvasRender from '../CanvasRender';
import BottomLabel from './BottomLabel';
import LeftLabel from './LeftLabel';
export function getBackground(props) {
  if (props.backgroundShow === false) return undefined;
  var _props$backgroundOffs = props.backgroundOffset,
      backgroundOffset = _props$backgroundOffs === void 0 ? BACKGROUND_OFFSET : _props$backgroundOffs,
      plotRect = props.plotRect,
      theme = props.theme;
  var backgroundRect = inset(-backgroundOffset, plotRect);
  var backgroundPath = getPath2D();
  backgroundPath.rect(backgroundRect.x, backgroundRect.y, backgroundRect.width, backgroundRect.height);
  return {
    fill: theme.plotBackgroundFill,
    path2D: backgroundPath,
    stroke: 'transparent',
    type: 'area'
  };
}
export function getXGuides(props, thick) {
  if (!_includes(props.groupedKeys, 'x')) return undefined;
  if (props.xShowGuides === false) return undefined;
  var _props$backgroundOffs2 = props.backgroundOffset,
      backgroundOffset = _props$backgroundOffs2 === void 0 ? BACKGROUND_OFFSET : _props$backgroundOffs2,
      plotRect = props.plotRect,
      theme = props.theme,
      xScale = props.xScale,
      xTicks = props.xTicks;
  return _map(xTicks, function (d) {
    var linePath = getPath2D();
    var x = xScale(d.value);
    linePath.moveTo(x, plotRect.y - backgroundOffset);
    linePath.lineTo(x, plotRect.y + plotRect.height + backgroundOffset);
    return {
      path2D: linePath,
      type: 'line',
      lineWidth: thick ? theme.guideZeroLineWidth : theme.guideLineWidth,
      stroke: thick ? theme.guideZeroStroke : theme.guideStroke
    };
  });
}
export function getYGuides(props, thick) {
  if (!_includes(props.groupedKeys, 'y')) return undefined;
  if (props.yShowGuides === false) return undefined;
  var _props$backgroundOffs3 = props.backgroundOffset,
      backgroundOffset = _props$backgroundOffs3 === void 0 ? BACKGROUND_OFFSET : _props$backgroundOffs3,
      plotRect = props.plotRect,
      theme = props.theme,
      yScale = props.yScale,
      yTicks = props.yTicks;
  return _map(yTicks, function (d) {
    var linePath = getPath2D();
    var y = yScale(d.value);
    linePath.moveTo(plotRect.x - backgroundOffset, y);
    linePath.lineTo(plotRect.x + plotRect.width + backgroundOffset, y);
    return {
      path2D: linePath,
      type: 'line',
      lineWidth: thick ? theme.guideZeroLineWidth : theme.guideLineWidth,
      stroke: thick ? theme.guideZeroStroke : theme.guideStroke
    };
  });
}
export function getXText(props) {
  if (!_includes(props.groupedKeys, 'x')) return undefined;
  if (props.xShowTicks === false) return undefined;
  var theme = props.theme;
  var defaultOffset = theme.axisTickFontSize * (theme.lineHeight - 1);
  var _props$backgroundOffs4 = props.backgroundOffset,
      backgroundOffset = _props$backgroundOffs4 === void 0 ? BACKGROUND_OFFSET : _props$backgroundOffs4,
      plotRect = props.plotRect,
      xScale = props.xScale,
      _props$xTickOffset = props.xTickOffset,
      xTickOffset = _props$xTickOffset === void 0 ? defaultOffset : _props$xTickOffset,
      xTicks = props.xTicks;
  return _map(xTicks, function (d) {
    return {
      type: 'text',
      text: d.text,
      x: xScale(d.value),
      y: _sum([backgroundOffset, plotRect.y, plotRect.height, xTickOffset]),
      textBaseline: 'top',
      textAlign: 'center',
      font: theme.axisTickFontSize + "px " + theme.fontFamilyMono
    };
  });
}
export function getYText(props) {
  if (!_includes(props.groupedKeys, 'y')) return undefined;
  if (props.yShowTicks === false) return undefined;
  var theme = props.theme;
  var defaultOffset = theme.axisTickFontSize * (theme.lineHeight - 1);
  var _props$backgroundOffs5 = props.backgroundOffset,
      backgroundOffset = _props$backgroundOffs5 === void 0 ? BACKGROUND_OFFSET : _props$backgroundOffs5,
      plotRect = props.plotRect,
      yScale = props.yScale,
      _props$yTickOffset = props.yTickOffset,
      yTickOffset = _props$yTickOffset === void 0 ? defaultOffset : _props$yTickOffset,
      yTicks = props.yTicks;
  return _map(yTicks, function (d) {
    return {
      type: 'text',
      text: d.text,
      x: _sum([plotRect.x, -backgroundOffset, -yTickOffset]),
      y: yScale(d.value),
      textAlign: 'right',
      textBaseline: 'middle',
      fill: theme.textFill,
      font: theme.axisTickFontSize + "px " + theme.fontFamilyMono
    };
  });
}
export function getBackgroundRenderData(props) {
  var background = getBackground(props);
  var xTicks = props.xTicks || getTicks(props, 'x');
  var yTicks = props.yTicks || getTicks(props, 'y');
  var xGuides = getXGuides(Object.assign({}, props, {
    xTicks: xTicks
  }));
  var yGuides = getYGuides(Object.assign({}, props, {
    yTicks: yTicks
  }));
  var xText = getXText(Object.assign({}, props, {
    xTicks: xTicks
  }));
  var yText = getYText(Object.assign({}, props, {
    yTicks: yTicks
  }));
  var thickXGuide = getXGuides(Object.assign({}, props, {
    xTicks: _filter(xTicks, function (d) {
      return d.value === 0;
    })
  }), true);
  var thickYGuide = getYGuides(Object.assign({}, props, {
    yTicks: _filter(yTicks, function (d) {
      return d.value === 0;
    })
  }), true);
  return _flatten(_compact([background, xGuides, yGuides, thickXGuide, thickYGuide, xText, yText]));
}

function getLabelText(props, key) {
  var text = props[key + "Name"] || props[key];
  if (text) return text;

  var layer = _findLast(props.layers, function (d) {
    return d[key + "Name"] || d[key];
  });

  if (layer) return layer[key + "Name"] || layer[key];
  return undefined;
}

export default function ChartBackground(props) {
  return React.createElement("div", null, React.createElement(CanvasRender, {
    height: props.height,
    plotRect: props.plotRect,
    renderData: getBackgroundRenderData(props),
    theme: props.theme,
    width: props.width
  }), props.yShowLabel ? React.createElement(LeftLabel, {
    plotRect: props.plotRect,
    text: getLabelText(props, 'y'),
    theme: props.theme
  }) : null, props.xShowLabel ? React.createElement(BottomLabel, {
    plotRect: props.plotRect,
    text: getLabelText(props, 'x'),
    theme: props.theme
  }) : null);
}
ChartBackground.propTypes = process.env.NODE_ENV !== "production" ? {
  height: PropTypes.number,
  onUpdate: PropTypes.func,
  plotRect: PropTypes.object,
  theme: PropTypes.object,
  width: PropTypes.number,
  x: PropTypes.string,
  xName: PropTypes.string,
  xShowLabel: PropTypes.bool,
  y: PropTypes.string,
  yName: PropTypes.string,
  yShowLabel: PropTypes.bool
} : {};
ChartBackground.defaultProps = {
  theme: DEFAULT_THEME,
  xShowLabel: true,
  yShowLabel: true
};