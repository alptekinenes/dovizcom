import _sum from "lodash/sum";
import _reduce from "lodash/reduce";
import _includes from "lodash/includes";
import { getCachedContext } from '../utils/canvasUtils';
import { marginInset } from '../utils/rectUtils';
import { getRange, getTickCount, getTicks } from './getForKey';
import { AXIS_LABEL_OFFSET, AXIS_TICK_OFFSET, BACKGROUND_OFFSET, SHOW_LABELS, SHOW_TICKS } from './defaults';
/*
`addPlotRect` calculate and assign the plotRect to a new props.
props.size gets insetted by props.margin to generate the plotRect.
when props.margin is not defined (or only partially defined), addPlotRect smartly calculates the margins, by taking into consideration axis label, ticks width and backgroundOffset.

@calling logic
addPlotRect{
  getTopMargin{}
  getBottomMargin{}
  getLeftMargin{
    getMaxTextWidth{}
  }
  getRightMargin{
    getTextWidth{}
  }
}

@example
addPlotRect({size})
returns {size, plotRect}
*/

export function getTextWidth(theme, string) {
  var ctx = getCachedContext();
  ctx.save();
  ctx.font = theme.axisTickFontSize + "px " + theme.fontFamilyMono;

  var _ctx$measureText = ctx.measureText(string),
      width = _ctx$measureText.width;

  ctx.restore();
  return width;
}
/*
get the maximum width of the strings contained in `ticks`.
Uses a offscreen canvas for doing the measure and takes into consideration the theme object.
*/

export function getMaxTextWidth(theme, ticks) {
  var ctx = getCachedContext();
  ctx.save();
  ctx.font = theme.axisTickFontSize + "px " + theme.fontFamilyMono;

  var maxWidth = _reduce(ticks, function (acc, d) {
    return Math.max(acc, ctx.measureText(d.text).width);
  }, 0);

  ctx.restore();
  return maxWidth;
}

function getTopMargin(props) {
  var _props$backgroundOffs = props.backgroundOffset,
      backgroundOffset = _props$backgroundOffs === void 0 ? BACKGROUND_OFFSET : _props$backgroundOffs,
      _props$margin = props.margin,
      margin = _props$margin === void 0 ? {} : _props$margin,
      theme = props.theme,
      y = props.y,
      _props$yShowTicks = props.yShowTicks,
      yShowTicks = _props$yShowTicks === void 0 ? SHOW_TICKS : _props$yShowTicks;
  if (margin.top !== undefined) return margin.top + backgroundOffset;
  if (yShowTicks === false || !y) return backgroundOffset;
  return Math.max(backgroundOffset, theme.axisTickFontSize / 2);
}

function getBottomMargin(props) {
  var theme = props.theme;
  var _props$backgroundOffs2 = props.backgroundOffset,
      backgroundOffset = _props$backgroundOffs2 === void 0 ? BACKGROUND_OFFSET : _props$backgroundOffs2,
      groupedKeys = props.groupedKeys,
      _props$margin2 = props.margin,
      margin = _props$margin2 === void 0 ? {} : _props$margin2,
      _props$xShowTicks = props.xShowTicks,
      xShowTicks = _props$xShowTicks === void 0 ? SHOW_TICKS : _props$xShowTicks,
      _props$xShowLabel = props.xShowLabel,
      xShowLabel = _props$xShowLabel === void 0 ? SHOW_LABELS : _props$xShowLabel,
      _props$xTickOffset = props.xTickOffset,
      xTickOffset = _props$xTickOffset === void 0 ? AXIS_TICK_OFFSET(theme) : _props$xTickOffset,
      _props$xLabelOffset = props.xLabelOffset,
      xLabelOffset = _props$xLabelOffset === void 0 ? AXIS_LABEL_OFFSET(theme) : _props$xLabelOffset;
  if (margin.bottom !== undefined) return margin.bottom + backgroundOffset;
  if (!_includes(groupedKeys, 'x')) return backgroundOffset;
  return _sum([backgroundOffset, xShowTicks ? xTickOffset + theme.axisTickFontSize : 0, xShowLabel ? xLabelOffset + theme.axisLabelFontSize : 0]);
}

function getLeftMargin(props) {
  var theme = props.theme;
  var _props$backgroundOffs3 = props.backgroundOffset,
      backgroundOffset = _props$backgroundOffs3 === void 0 ? BACKGROUND_OFFSET : _props$backgroundOffs3,
      groupedKeys = props.groupedKeys,
      _props$margin3 = props.margin,
      margin = _props$margin3 === void 0 ? {} : _props$margin3,
      _props$yShowTicks2 = props.yShowTicks,
      yShowTicks = _props$yShowTicks2 === void 0 ? SHOW_TICKS : _props$yShowTicks2,
      _props$yShowLabel = props.yShowLabel,
      yShowLabel = _props$yShowLabel === void 0 ? SHOW_LABELS : _props$yShowLabel,
      _props$yTickOffset = props.yTickOffset,
      yTickOffset = _props$yTickOffset === void 0 ? AXIS_TICK_OFFSET(theme) : _props$yTickOffset,
      _props$yLabelOffset = props.yLabelOffset,
      yLabelOffset = _props$yLabelOffset === void 0 ? AXIS_LABEL_OFFSET(theme) : _props$yLabelOffset;
  if (margin.left !== undefined) return margin.left + backgroundOffset;
  if (!_includes(groupedKeys, 'y')) return backgroundOffset;

  if (!yShowTicks) {
    return _sum([backgroundOffset, yShowLabel ? yLabelOffset + theme.axisLabelFontSize : 0]);
  }

  var yRange = props.yRange || getRange(props, 'y');
  var yTickCount = props.yTickCount || getTickCount(Object.assign({}, props, {
    yRange: yRange
  }), 'y');
  var yTicks = props.yTicks || getTicks(Object.assign({}, props, {
    yTickCount: yTickCount
  }), 'y');
  var yMaxTickWidth = getMaxTextWidth(theme, yTicks);
  return _sum([backgroundOffset, yMaxTickWidth, yShowTicks ? yTickOffset : 0, yShowLabel ? yLabelOffset + 5 + theme.axisLabelFontSize : 0]);
}

function getRightMargin(props) {
  var _props$backgroundOffs4 = props.backgroundOffset,
      backgroundOffset = _props$backgroundOffs4 === void 0 ? BACKGROUND_OFFSET : _props$backgroundOffs4,
      _props$margin4 = props.margin,
      margin = _props$margin4 === void 0 ? {} : _props$margin4,
      x = props.x,
      _props$xShowTicks2 = props.xShowTicks,
      xShowTicks = _props$xShowTicks2 === void 0 ? SHOW_TICKS : _props$xShowTicks2;
  if (margin.right !== undefined) return margin.right + backgroundOffset;
  if (!x || !xShowTicks) return backgroundOffset;
  return backgroundOffset;
}

export function getPlotRect(props) {
  if (props.plotRect) return props;
  var _props$backgroundOffs5 = props.backgroundOffset,
      backgroundOffset = _props$backgroundOffs5 === void 0 ? BACKGROUND_OFFSET : _props$backgroundOffs5,
      groupedKeys = props.groupedKeys,
      width = props.width,
      _props$height = props.height,
      height = _props$height === void 0 ? props.width * props.proportion : _props$height;
  var top = getTopMargin(props);
  var bottom = getBottomMargin(props);
  var partialPlotRect = marginInset({
    bottom: bottom,
    top: top
  }, {
    width: width,
    height: height
  });
  var left = getLeftMargin(Object.assign({}, props, {
    plotRect: partialPlotRect
  }));
  partialPlotRect = marginInset({
    bottom: bottom,
    top: top,
    left: left
  }, {
    width: width,
    height: height
  });
  var right = getRightMargin(Object.assign({}, props, {
    plotRect: partialPlotRect
  }));
  var margin = {
    left: left,
    bottom: bottom,
    top: top,
    right: right
  };
  var newWidth = width;
  var newHeight = height;
  var plotRect = marginInset(margin, {
    width: width,
    height: height
  });

  if (!_includes(groupedKeys, 'x')) {
    newWidth -= plotRect.width;
    plotRect.width = 0;
  }

  if (!_includes(groupedKeys, 'y')) {
    newHeight -= plotRect.height;
    plotRect.height = 0;
  }

  if (plotRect.height < 0) {
    plotRect.height = 0;
    newHeight = top + bottom;
  }

  if (plotRect.width < 0) {
    plotRect.width = 0;
    newWidth = left + right;
  }

  return {
    backgroundOffset: backgroundOffset,
    margin: margin,
    plotRect: plotRect,
    width: newWidth,
    height: newHeight
  };
}